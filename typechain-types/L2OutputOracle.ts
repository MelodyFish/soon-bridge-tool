/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace Types {
  export type OutputProposalStruct = {
    outputRoot: PromiseOrValue<BytesLike>;
    timestamp: PromiseOrValue<BigNumberish>;
    l2BlockNumber: PromiseOrValue<BigNumberish>;
  };

  export type OutputProposalStructOutput = [string, BigNumber, BigNumber] & {
    outputRoot: string;
    timestamp: BigNumber;
    l2BlockNumber: BigNumber;
  };
}

export interface L2OutputOracleInterface extends utils.Interface {
  functions: {
    "CHALLENGER()": FunctionFragment;
    "FINALIZATION_PERIOD_SECONDS()": FunctionFragment;
    "L2_BLOCK_TIME()": FunctionFragment;
    "PROPOSER()": FunctionFragment;
    "SUBMISSION_INTERVAL()": FunctionFragment;
    "challenger()": FunctionFragment;
    "computeL2Timestamp(uint256)": FunctionFragment;
    "deleteL2Outputs(uint256)": FunctionFragment;
    "finalizationPeriodSeconds()": FunctionFragment;
    "getL2Output(uint256)": FunctionFragment;
    "getL2OutputAfter(uint256)": FunctionFragment;
    "getL2OutputIndexAfter(uint256)": FunctionFragment;
    "initialize(uint256,uint256)": FunctionFragment;
    "l2BlockTime()": FunctionFragment;
    "latestBlockNumber()": FunctionFragment;
    "latestOutputIndex()": FunctionFragment;
    "nextBlockNumber()": FunctionFragment;
    "nextOutputIndex()": FunctionFragment;
    "proposeL2Output(bytes32,uint256,bytes32,uint256)": FunctionFragment;
    "proposer()": FunctionFragment;
    "startingBlockNumber()": FunctionFragment;
    "startingTimestamp()": FunctionFragment;
    "submissionInterval()": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "CHALLENGER"
      | "FINALIZATION_PERIOD_SECONDS"
      | "L2_BLOCK_TIME"
      | "PROPOSER"
      | "SUBMISSION_INTERVAL"
      | "challenger"
      | "computeL2Timestamp"
      | "deleteL2Outputs"
      | "finalizationPeriodSeconds"
      | "getL2Output"
      | "getL2OutputAfter"
      | "getL2OutputIndexAfter"
      | "initialize"
      | "l2BlockTime"
      | "latestBlockNumber"
      | "latestOutputIndex"
      | "nextBlockNumber"
      | "nextOutputIndex"
      | "proposeL2Output"
      | "proposer"
      | "startingBlockNumber"
      | "startingTimestamp"
      | "submissionInterval"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CHALLENGER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FINALIZATION_PERIOD_SECONDS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "L2_BLOCK_TIME",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "PROPOSER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "SUBMISSION_INTERVAL",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "challenger",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "computeL2Timestamp",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteL2Outputs",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizationPeriodSeconds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getL2Output",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getL2OutputAfter",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getL2OutputIndexAfter",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "l2BlockTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "latestBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "latestOutputIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextOutputIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposeL2Output",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "proposer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "startingBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startingTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "submissionInterval",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(functionFragment: "CHALLENGER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "FINALIZATION_PERIOD_SECONDS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "L2_BLOCK_TIME",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "PROPOSER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "SUBMISSION_INTERVAL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "challenger", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "computeL2Timestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteL2Outputs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizationPeriodSeconds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getL2Output",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getL2OutputAfter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getL2OutputIndexAfter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "l2BlockTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestOutputIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextOutputIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeL2Output",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proposer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "startingBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startingTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submissionInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "OutputProposed(bytes32,uint256,uint256,uint256)": EventFragment;
    "OutputsDeleted(uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OutputProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OutputsDeleted"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OutputProposedEventObject {
  outputRoot: string;
  l2OutputIndex: BigNumber;
  l2BlockNumber: BigNumber;
  l1Timestamp: BigNumber;
}
export type OutputProposedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  OutputProposedEventObject
>;

export type OutputProposedEventFilter = TypedEventFilter<OutputProposedEvent>;

export interface OutputsDeletedEventObject {
  prevNextOutputIndex: BigNumber;
  newNextOutputIndex: BigNumber;
}
export type OutputsDeletedEvent = TypedEvent<
  [BigNumber, BigNumber],
  OutputsDeletedEventObject
>;

export type OutputsDeletedEventFilter = TypedEventFilter<OutputsDeletedEvent>;

export interface L2OutputOracle extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L2OutputOracleInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The address of the challenger. Can be updated via upgrade. This will be removed in the         future, use `challenger` instead.
     */
    CHALLENGER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
     */
    FINALIZATION_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
     */
    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The address of the proposer. Can be updated via upgrade.  This will be removed in the         future, use `proposer` instead.
     */
    PROPOSER(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The interval in L2 blocks at which checkpoints must be submitted.         Although this is immutable, it can safely be modified by upgrading the         implementation contract.         Public getter is legacy and will be removed in the future. Use `submissionInterval`         instead.
     */
    SUBMISSION_INTERVAL(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Getter for the challenger address.
     */
    challenger(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the L2 timestamp corresponding to a given L2 block number.
     * @param _l2BlockNumber The L2 block number of the target block.
     */
    computeL2Timestamp(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Deletes all output proposals after and including the proposal that corresponds to         the given output index. Only the challenger address can delete outputs.
     * @param _l2OutputIndex Index of the first L2 output to be deleted.                       All outputs after this output will also be deleted.
     */
    deleteL2Outputs(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Getter for the FINALIZATION_PERIOD_SECONDS.
     */
    finalizationPeriodSeconds(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns an output by index. Needed to return a struct instead of a tuple.
     * @param _l2OutputIndex Index of the output to return.
     */
    getL2Output(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[Types.OutputProposalStructOutput]>;

    /**
     * Returns the L2 output proposal that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[Types.OutputProposalStructOutput]>;

    /**
     * Returns the index of the L2 output that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputIndexAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Initializer.
     * @param _startingBlockNumber Block number for the first recoded L2 block.
     * @param _startingTimestamp Timestamp for the first recoded L2 block.
     */
    initialize(
      _startingBlockNumber: PromiseOrValue<BigNumberish>,
      _startingTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Getter for the L2_BLOCK_TIME.
     */
    l2BlockTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns the block number of the latest submitted L2 output proposal.         If no proposals been submitted yet then this function will return the starting         block number.
     */
    latestBlockNumber(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns the number of outputs that have been proposed.         Will revert if no outputs have been proposed yet.
     */
    latestOutputIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Computes the block number of the next L2 block that needs to be checkpointed.
     */
    nextBlockNumber(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Returns the index of the next output to be proposed.
     */
    nextOutputIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Accepts an outputRoot and the timestamp of the corresponding L2 block.         The timestamp must be equal to the current value returned by `nextTimestamp()` in         order to be accepted. This function may only be called by the Proposer.
     * @param _l1BlockHash A block hash which must be included in the current chain.
     * @param _l1BlockNumber The block number with the specified block hash.
     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
     * @param _outputRoot The L2 output of the checkpoint block.
     */
    proposeL2Output(
      _outputRoot: PromiseOrValue<BytesLike>,
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      _l1BlockHash: PromiseOrValue<BytesLike>,
      _l1BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Getter for the PROPOSER address.
     */
    proposer(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The number of the first L2 block recorded in this contract.
     */
    startingBlockNumber(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The timestamp of the first L2 block recorded in this contract.
     */
    startingTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Getter for the SUBMISSION_INTERVAL.
     */
    submissionInterval(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<[string]>;
  };

  /**
   * The address of the challenger. Can be updated via upgrade. This will be removed in the         future, use `challenger` instead.
   */
  CHALLENGER(overrides?: CallOverrides): Promise<string>;

  /**
   * The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
   */
  FINALIZATION_PERIOD_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
   */
  L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The address of the proposer. Can be updated via upgrade.  This will be removed in the         future, use `proposer` instead.
   */
  PROPOSER(overrides?: CallOverrides): Promise<string>;

  /**
   * The interval in L2 blocks at which checkpoints must be submitted.         Although this is immutable, it can safely be modified by upgrading the         implementation contract.         Public getter is legacy and will be removed in the future. Use `submissionInterval`         instead.
   */
  SUBMISSION_INTERVAL(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Getter for the challenger address.
   */
  challenger(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the L2 timestamp corresponding to a given L2 block number.
   * @param _l2BlockNumber The L2 block number of the target block.
   */
  computeL2Timestamp(
    _l2BlockNumber: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Deletes all output proposals after and including the proposal that corresponds to         the given output index. Only the challenger address can delete outputs.
   * @param _l2OutputIndex Index of the first L2 output to be deleted.                       All outputs after this output will also be deleted.
   */
  deleteL2Outputs(
    _l2OutputIndex: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Getter for the FINALIZATION_PERIOD_SECONDS.
   */
  finalizationPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns an output by index. Needed to return a struct instead of a tuple.
   * @param _l2OutputIndex Index of the output to return.
   */
  getL2Output(
    _l2OutputIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<Types.OutputProposalStructOutput>;

  /**
   * Returns the L2 output proposal that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
   * @param _l2BlockNumber L2 block number to find a checkpoint for.
   */
  getL2OutputAfter(
    _l2BlockNumber: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<Types.OutputProposalStructOutput>;

  /**
   * Returns the index of the L2 output that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
   * @param _l2BlockNumber L2 block number to find a checkpoint for.
   */
  getL2OutputIndexAfter(
    _l2BlockNumber: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Initializer.
   * @param _startingBlockNumber Block number for the first recoded L2 block.
   * @param _startingTimestamp Timestamp for the first recoded L2 block.
   */
  initialize(
    _startingBlockNumber: PromiseOrValue<BigNumberish>,
    _startingTimestamp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Getter for the L2_BLOCK_TIME.
   */
  l2BlockTime(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the block number of the latest submitted L2 output proposal.         If no proposals been submitted yet then this function will return the starting         block number.
   */
  latestBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the number of outputs that have been proposed.         Will revert if no outputs have been proposed yet.
   */
  latestOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Computes the block number of the next L2 block that needs to be checkpointed.
   */
  nextBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns the index of the next output to be proposed.
   */
  nextOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Accepts an outputRoot and the timestamp of the corresponding L2 block.         The timestamp must be equal to the current value returned by `nextTimestamp()` in         order to be accepted. This function may only be called by the Proposer.
   * @param _l1BlockHash A block hash which must be included in the current chain.
   * @param _l1BlockNumber The block number with the specified block hash.
   * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
   * @param _outputRoot The L2 output of the checkpoint block.
   */
  proposeL2Output(
    _outputRoot: PromiseOrValue<BytesLike>,
    _l2BlockNumber: PromiseOrValue<BigNumberish>,
    _l1BlockHash: PromiseOrValue<BytesLike>,
    _l1BlockNumber: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Getter for the PROPOSER address.
   */
  proposer(overrides?: CallOverrides): Promise<string>;

  /**
   * The number of the first L2 block recorded in this contract.
   */
  startingBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The timestamp of the first L2 block recorded in this contract.
   */
  startingTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Getter for the SUBMISSION_INTERVAL.
   */
  submissionInterval(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Semantic version.
   */
  version(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * The address of the challenger. Can be updated via upgrade. This will be removed in the         future, use `challenger` instead.
     */
    CHALLENGER(overrides?: CallOverrides): Promise<string>;

    /**
     * The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
     */
    FINALIZATION_PERIOD_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
     */
    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The address of the proposer. Can be updated via upgrade.  This will be removed in the         future, use `proposer` instead.
     */
    PROPOSER(overrides?: CallOverrides): Promise<string>;

    /**
     * The interval in L2 blocks at which checkpoints must be submitted.         Although this is immutable, it can safely be modified by upgrading the         implementation contract.         Public getter is legacy and will be removed in the future. Use `submissionInterval`         instead.
     */
    SUBMISSION_INTERVAL(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the challenger address.
     */
    challenger(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the L2 timestamp corresponding to a given L2 block number.
     * @param _l2BlockNumber The L2 block number of the target block.
     */
    computeL2Timestamp(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Deletes all output proposals after and including the proposal that corresponds to         the given output index. Only the challenger address can delete outputs.
     * @param _l2OutputIndex Index of the first L2 output to be deleted.                       All outputs after this output will also be deleted.
     */
    deleteL2Outputs(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Getter for the FINALIZATION_PERIOD_SECONDS.
     */
    finalizationPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an output by index. Needed to return a struct instead of a tuple.
     * @param _l2OutputIndex Index of the output to return.
     */
    getL2Output(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<Types.OutputProposalStructOutput>;

    /**
     * Returns the L2 output proposal that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<Types.OutputProposalStructOutput>;

    /**
     * Returns the index of the L2 output that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputIndexAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializer.
     * @param _startingBlockNumber Block number for the first recoded L2 block.
     * @param _startingTimestamp Timestamp for the first recoded L2 block.
     */
    initialize(
      _startingBlockNumber: PromiseOrValue<BigNumberish>,
      _startingTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Getter for the L2_BLOCK_TIME.
     */
    l2BlockTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the block number of the latest submitted L2 output proposal.         If no proposals been submitted yet then this function will return the starting         block number.
     */
    latestBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the number of outputs that have been proposed.         Will revert if no outputs have been proposed yet.
     */
    latestOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Computes the block number of the next L2 block that needs to be checkpointed.
     */
    nextBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the index of the next output to be proposed.
     */
    nextOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Accepts an outputRoot and the timestamp of the corresponding L2 block.         The timestamp must be equal to the current value returned by `nextTimestamp()` in         order to be accepted. This function may only be called by the Proposer.
     * @param _l1BlockHash A block hash which must be included in the current chain.
     * @param _l1BlockNumber The block number with the specified block hash.
     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
     * @param _outputRoot The L2 output of the checkpoint block.
     */
    proposeL2Output(
      _outputRoot: PromiseOrValue<BytesLike>,
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      _l1BlockHash: PromiseOrValue<BytesLike>,
      _l1BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Getter for the PROPOSER address.
     */
    proposer(overrides?: CallOverrides): Promise<string>;

    /**
     * The number of the first L2 block recorded in this contract.
     */
    startingBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The timestamp of the first L2 block recorded in this contract.
     */
    startingTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the SUBMISSION_INTERVAL.
     */
    submissionInterval(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OutputProposed(bytes32,uint256,uint256,uint256)"(
      outputRoot?: PromiseOrValue<BytesLike> | null,
      l2OutputIndex?: PromiseOrValue<BigNumberish> | null,
      l2BlockNumber?: PromiseOrValue<BigNumberish> | null,
      l1Timestamp?: null
    ): OutputProposedEventFilter;
    OutputProposed(
      outputRoot?: PromiseOrValue<BytesLike> | null,
      l2OutputIndex?: PromiseOrValue<BigNumberish> | null,
      l2BlockNumber?: PromiseOrValue<BigNumberish> | null,
      l1Timestamp?: null
    ): OutputProposedEventFilter;

    "OutputsDeleted(uint256,uint256)"(
      prevNextOutputIndex?: PromiseOrValue<BigNumberish> | null,
      newNextOutputIndex?: PromiseOrValue<BigNumberish> | null
    ): OutputsDeletedEventFilter;
    OutputsDeleted(
      prevNextOutputIndex?: PromiseOrValue<BigNumberish> | null,
      newNextOutputIndex?: PromiseOrValue<BigNumberish> | null
    ): OutputsDeletedEventFilter;
  };

  estimateGas: {
    /**
     * The address of the challenger. Can be updated via upgrade. This will be removed in the         future, use `challenger` instead.
     */
    CHALLENGER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
     */
    FINALIZATION_PERIOD_SECONDS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
     */
    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The address of the proposer. Can be updated via upgrade.  This will be removed in the         future, use `proposer` instead.
     */
    PROPOSER(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The interval in L2 blocks at which checkpoints must be submitted.         Although this is immutable, it can safely be modified by upgrading the         implementation contract.         Public getter is legacy and will be removed in the future. Use `submissionInterval`         instead.
     */
    SUBMISSION_INTERVAL(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the challenger address.
     */
    challenger(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the L2 timestamp corresponding to a given L2 block number.
     * @param _l2BlockNumber The L2 block number of the target block.
     */
    computeL2Timestamp(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Deletes all output proposals after and including the proposal that corresponds to         the given output index. Only the challenger address can delete outputs.
     * @param _l2OutputIndex Index of the first L2 output to be deleted.                       All outputs after this output will also be deleted.
     */
    deleteL2Outputs(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Getter for the FINALIZATION_PERIOD_SECONDS.
     */
    finalizationPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an output by index. Needed to return a struct instead of a tuple.
     * @param _l2OutputIndex Index of the output to return.
     */
    getL2Output(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the L2 output proposal that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the index of the L2 output that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputIndexAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Initializer.
     * @param _startingBlockNumber Block number for the first recoded L2 block.
     * @param _startingTimestamp Timestamp for the first recoded L2 block.
     */
    initialize(
      _startingBlockNumber: PromiseOrValue<BigNumberish>,
      _startingTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Getter for the L2_BLOCK_TIME.
     */
    l2BlockTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the block number of the latest submitted L2 output proposal.         If no proposals been submitted yet then this function will return the starting         block number.
     */
    latestBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the number of outputs that have been proposed.         Will revert if no outputs have been proposed yet.
     */
    latestOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Computes the block number of the next L2 block that needs to be checkpointed.
     */
    nextBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the index of the next output to be proposed.
     */
    nextOutputIndex(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Accepts an outputRoot and the timestamp of the corresponding L2 block.         The timestamp must be equal to the current value returned by `nextTimestamp()` in         order to be accepted. This function may only be called by the Proposer.
     * @param _l1BlockHash A block hash which must be included in the current chain.
     * @param _l1BlockNumber The block number with the specified block hash.
     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
     * @param _outputRoot The L2 output of the checkpoint block.
     */
    proposeL2Output(
      _outputRoot: PromiseOrValue<BytesLike>,
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      _l1BlockHash: PromiseOrValue<BytesLike>,
      _l1BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Getter for the PROPOSER address.
     */
    proposer(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The number of the first L2 block recorded in this contract.
     */
    startingBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The timestamp of the first L2 block recorded in this contract.
     */
    startingTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Getter for the SUBMISSION_INTERVAL.
     */
    submissionInterval(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The address of the challenger. Can be updated via upgrade. This will be removed in the         future, use `challenger` instead.
     */
    CHALLENGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The minimum time (in seconds) that must elapse before a withdrawal can be finalized.
     */
    FINALIZATION_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.
     */
    L2_BLOCK_TIME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The address of the proposer. Can be updated via upgrade.  This will be removed in the         future, use `proposer` instead.
     */
    PROPOSER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The interval in L2 blocks at which checkpoints must be submitted.         Although this is immutable, it can safely be modified by upgrading the         implementation contract.         Public getter is legacy and will be removed in the future. Use `submissionInterval`         instead.
     */
    SUBMISSION_INTERVAL(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Getter for the challenger address.
     */
    challenger(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the L2 timestamp corresponding to a given L2 block number.
     * @param _l2BlockNumber The L2 block number of the target block.
     */
    computeL2Timestamp(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deletes all output proposals after and including the proposal that corresponds to         the given output index. Only the challenger address can delete outputs.
     * @param _l2OutputIndex Index of the first L2 output to be deleted.                       All outputs after this output will also be deleted.
     */
    deleteL2Outputs(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Getter for the FINALIZATION_PERIOD_SECONDS.
     */
    finalizationPeriodSeconds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an output by index. Needed to return a struct instead of a tuple.
     * @param _l2OutputIndex Index of the output to return.
     */
    getL2Output(
      _l2OutputIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the L2 output proposal that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the index of the L2 output that checkpoints a given L2 block number.         Uses a binary search to find the first output greater than or equal to the given         block.
     * @param _l2BlockNumber L2 block number to find a checkpoint for.
     */
    getL2OutputIndexAfter(
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Initializer.
     * @param _startingBlockNumber Block number for the first recoded L2 block.
     * @param _startingTimestamp Timestamp for the first recoded L2 block.
     */
    initialize(
      _startingBlockNumber: PromiseOrValue<BigNumberish>,
      _startingTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Getter for the L2_BLOCK_TIME.
     */
    l2BlockTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the block number of the latest submitted L2 output proposal.         If no proposals been submitted yet then this function will return the starting         block number.
     */
    latestBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the number of outputs that have been proposed.         Will revert if no outputs have been proposed yet.
     */
    latestOutputIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Computes the block number of the next L2 block that needs to be checkpointed.
     */
    nextBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the index of the next output to be proposed.
     */
    nextOutputIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Accepts an outputRoot and the timestamp of the corresponding L2 block.         The timestamp must be equal to the current value returned by `nextTimestamp()` in         order to be accepted. This function may only be called by the Proposer.
     * @param _l1BlockHash A block hash which must be included in the current chain.
     * @param _l1BlockNumber The block number with the specified block hash.
     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
     * @param _outputRoot The L2 output of the checkpoint block.
     */
    proposeL2Output(
      _outputRoot: PromiseOrValue<BytesLike>,
      _l2BlockNumber: PromiseOrValue<BigNumberish>,
      _l1BlockHash: PromiseOrValue<BytesLike>,
      _l1BlockNumber: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Getter for the PROPOSER address.
     */
    proposer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The number of the first L2 block recorded in this contract.
     */
    startingBlockNumber(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The timestamp of the first L2 block recorded in this contract.
     */
    startingTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Getter for the SUBMISSION_INTERVAL.
     */
    submissionInterval(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Semantic version.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
